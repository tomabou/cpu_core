FPGAが届いた

Quartusの使い方を何とか把握しようとした

PLLを使うことが出来た
model simを使った
シリアル通信モジュールを買った

シリアル通信を実装する

7/15
シリアル通信が動いた

次はメモリを使ってみるか？

メモリにシリアル通信でプログラムを配置して、実行するという形にしたい（ノイマン型）


8/20
院試が終わった
レジスタを書いてみた
riscvの仕様書を眺めてどれから実装しようか考える
先にどの命令を実装するか決めた方が良いかもしれない
とりあえずの目標を何にするか？
即値をレジスタに入れて、足し算
その次は条件分岐を入れてfibo
そのあとIOとメモリ

あとアセンブラを書いた方が良いかも
mifファイルを出力するやつ

8/21
とりあえず足し算を動かすことを目標にした
その後、メモリを使えるようにして、条件分岐を実装する。
大体パーツは書いたので、コントロールラインがクロックによって遅れることを実装すると足し算が動くはず
data memory はモック
コントロールはもっと複雑になったときにちゃんと書くのが大変そうである
case文のネストみたいな感じで書くのか
どれくらい論理合成するときに最適化してくれるかも不明
まあとりあえず動けばよい
明日中に実機で動くといいな
メモリを実機で使ったことがないのでちゃんと動くかは少し不安
あとPLLも

明日の予定
コントロールラインのパイプラインを書く
nibu.vのテストベンチを書く
実機で動かしてみる


8/22
微妙にmifファイルのmodelsimでの扱い方が分からない
Hizになってしまったので一回落としてもう一回起動したら動いた 謎
コントロールのパイプラインを書いた
add 0 でno opが実現できるか？
Noopを実装して、実機で動かす

mifファイルはmodelsimでは対応していないみたいである
現状quartusでコンパイルしておけば動くのだが、どのファイルが大事なのかはわからない
modelsimで再コンパイルすると死ぬ
mifファイルでなくhexファイルを使えばワンちゃんあるかも

あとはクロックを書けば多分動くのだが、mifファイルがガバいのはつらいので、それを修正するのが先かもしれない
50Mhzのクロックが入ってくるので、それこそ2Hzとかまで落として観測したい

8/23
メモリの謎のバグの原因が分かった
ramなのが悪い
多分ramはアドレスを効率的にするために内部配置を可変にしている
なので、mifファイルで初期化してもちゃんと初期化されないみたい
めっちゃ時間食われたけど解決してよかった

バグの原因はusbblasterからメモリの中身を見るやつだった
あれを入れるとめちゃくちゃになる

それとは別に、PCが突然5増えるというバグがある
noopを10挟むことでとりあえずその他の部分の確認はできたが、発生条件が分からない
rtlシミュレーションでは再現しない
leの表（ネットリスト？）を眺めてもなぜ5増えるのか全く分からない
単純に4を足しているだけなのに
これfpgaボードのせいである気がしていて、ledの下の方の出力を0にしておけば起こらない（必要十分条件からは程遠いと思うが）
どこかのLEDへのピンがonになっているときに、スイッチのチャタリング除去回路が機能しなくなっている説
それで高速にincrementだけされてうまくメモリが読みだされない みたいな
とりあえず10このLEDを光らせない方が良い気がする

あまり納得できないが、とりあえずRTLシミュレーションとFPGAの挙動が一致したので、次の機能を実装していく
ramと、ジャンプ系
memory mapped ioを使うので、ramを実装した後に実装したい

順序としては、
2オペランド演算
ジャンプ
1から6までの和の計算
ram
フィボナッチ
io
対話式の何か

対話式の何かはコンパイラが無いとキツそうである
コンパイラをどうするか
とりあえずclangを使ってみるか？
それともフルスクラッチで書くか
その前に多分アセンブラ(to mif file)が必要だけど


8/24

2オペランド演算は多分動いてる
mifファイルをmodelsim側から読む方法が分からないので、
mifを弄るたびに起動し直すのがめんどくさい
ので、先にテストファイルを作る必要がある
これは多分アセンブラが必要
アセンブラは軽井沢で作るかな

このdataflowだと、PCを読む方法がないので、AUIPC(add upper immediate to pc)が実装できない
あとJAL JALRも
JALはPCをwrite registerに流し込めれば大丈夫
JALRはそれに加えてregisterの値をPCに足す部分が必要
aluを利用するのか、それとも別のmoduleを用意するのか
conditional branchは実装できる

JALをまず実装して、その後conditional branch
JALRってジャンプ先計算する前にregisterから読みださなきゃいけないからパフォーマンスどうしても落ちそう
でもかなり遠いところに飛ぶときしか使わないから、まあ大丈夫なのかな

JALを書いたつもり
テストケースを書くのがそろそろ面倒なので、アセンブラとシミュレータがそろそろ欲しくなってきた
軽井沢で書けたら良いなー

8/25
addとaddiのアセンブラを書いた
mifを出力して実機に書き込んで動くところまで確認
次は
ジャンプ命令をdecodeできるようにしてunconditional jumpの挙動を確認する

パイプライン回りをどれくらい真面目に実装するか
register forwardingとか実装するか？？
別にパイプラインしなくても定数倍遅くなってそれで終わり

jalは実装できたので次はconditional branchを実装する
conditional branchも多分大体実装できているように見える

次はメモリを実装して、fiboを計算する
1から10までの和とかを計算しても良いかもしれない


8/26
load storeのHDLを書いたつもり
次はassemblerを書いてテストする
assemblerを書く方がめんどくさい説はあるよね
タイミング制約みたいな話は何も分からないので調べなければ

load storeが動いたように見える
次やることとしては、
IO
特にuartIOと、7segIO 
フィボナッチ計算 これはjalのPCをちゃんとやるところが動いてるかの確認になる
- これはIOを実装した後の方が楽しい気がする

nopが連続しているのは相当ダサいので、レジスタフォワーディングの実装

まともなクロックで動かす
タイミング制約を書く aluとかかなりクリティカルパスが長い
アセンブラの機能の追加 特に対応しているエイリアスを増やして、compire explorerとかの出力を直接入力できるようにしたい
フィボナッチとか自分で書くのきついので

7segio
アセンブラ
フィボナッチ -> jalがちゃんとlink出来ているかの確認
uartio
の順番かな
ioの番地はマイナス番地にしておくと良い気もする
いやマイナス番地は意味が分からないので、若い番地にしておこう
uartioは、uartは8bitなので、なにもFIFOに入っていなかったら256（もしくは-1かな）が返ってくるとかが良い気がする

8/27
segioを実装した
シミュレーターがそろそろあった方が良いのかなぁ
コンパイラを弄り始めるならば確実にあった方が良いのだけれど
jalrを実装してないのでは
conditional branchの為にアドレス計算とは別にaluを使う必要がある
なのでアドレス計算はaluを用いないようにした
じゃあjalrの時はどうしようか
pc <= imm + rs1
なので、aluで計算してmuxでpcにぶち込むのを選択する
フィボナッチ実装できた 6番目のフィボナッチは13だった
マージでデバックがキツカッタ

lui,auipcを実装した方が良いかも
今はjalrのオフセットの計算の仕方がおかしい

pllを使ってuartを動かしてみよう
pllを使ってuartの送受信ができた

これをcpuに組み込むクロックが違うのでfifoを使う
ポチポチクロックをやめる
auipc luiの実装
簡単な対話式プログラムを書いてみる
そろそろシミュレーターやらコンパイラが必要か


8/28
uart moduleを書いた 受信のテストベンチは動いた
uartが動くことを確認したらcpuのクロックも追加してみよう
uartinputのところでハングさせればデバックもしやすい気がする
coreのテストはcoreのテスト単体でやればいいので

アセンブラをどうするかという話があったが、
前方宣言だけして、clanfunction call命令だけ残しておいて
アセンブラで処理することにする
そうすると出力されたアセンブラをそのまま活用することが出来る

命令メモリとデータメモリを分けなきゃいけない問題
くっつけたかったら
dual port ramを使えばいいのでは
完全にそれである気がする
本当は外部メモリを使った方が良い気もするんだけどそれはかなり難しい気がするので後回し

todo
uartioの実装 (rcvのテストベンチを動かしたところまでやった)
coreにclockを流し込む
lui auipcを実装
対話式でフィボナッチ数列を計算する

8/29
windows updataで1903 buildになった
不具合が出ないといいけど

memory mapped ioだと、readに冪等性がなくなるので、read ctrlが必要になる
uart ioが動いた（入力に対して1を足して返してくる）
やったぜ
lui auipcの実装
アセンブリをもっとやりやすく（要検討）
パイプラインハザードに対する対処
    ブランチはOK
    レジスタはレジスタフォワーディングを実装したい
    load命令によるハザードはハードウェア側で対処したい（nopを入れるのはダサい）
    どうやって遅延スロットを入れるのか）
タイミング制約的なのをどうやって入れるか
浮動小数点、掛算割り算の実装をするか（目的プログラムは何にする？）
割り算とかは1クロックで終わらせるのは大変？そうするとパイプラインがもっと難しくなる可能性…
アセンブリを弄らなくても一発で実行まで持って行けるようにしたい

8/30
auipcを直してfiboを動かした
やっぱデバッグがやりにくいかも
アセンブラのミスなのかcoreのミスなのかの判別がキツイ
少なくとも毎回quortus上でコンパイルするのはダサい
inst memoryとdata memoryを統合して2port ramにして、
uart経由でプログラムを書き込むようにした方が良いんではないだろうか
関数呼び出しも出来るようになったのでプログラムローダーを書く準備は
出来ている

9/1
今後の順序としては
2port ramにする
プログラムローダーを書く
テストベンチ自動生成スクリプトを書く
コンパイラから直接使えるようにする
レジスタフォワーディングの実装
タイミング制約を入れてコンパイルする
FPUの実装（FPUのIPの調査）

FPUのIP 周波数と遅延のトレードオフが存在した（それはそう）
ramを使えば段数を減らせたりするのかも？（IPとして存在するか不明）

コンパイラはclangを用いることにする（もしかしたらgccかも）
windowsを使っているので、wsl上に環境を構築するのが丸いんじゃなかろうか
IOはインラインアセンブリを使うかリンクをするかどちらか
インラインアセンブリの方が良いかも

riscのパイプラインで、演算とメモリアクセスが別個になっているのが少し謎
offsetを計算するためのaddはもしかしたら割と重たい計算なのかも
write backのタイミングが揃っていると諸々の実装が楽でよいという事が分かった
浮動小数点レジスタを別に用意したりするとその辺も楽なんだろう
パイプラインの長さを簡単に変えられる
loadが間に合わないハザードを回避するためにバブルする必要があるのだが、今の実装だとそれが少し書きにくい気がする
branch命令に関しては、branchのpredictionを外したらメモリへの書き込みとレジスタへの書き込みを止めることで対処できている
しかし、ハザードは多分パイプラインを進めるのを一旦止めるみたいな感じで書きたい
それは書き漏らしが発生しそうなので、各ステージでmoduleを分けるみたいな実装をした方が良いのかもしれない
現状のように、ハザードをアセンブリ側で対処するって言う手もないわけでないとは思うんだけれども
しかしレジスタフォワーディングとか実装すると各ステージを逆流するみたいなデータパスがいっぱい生えるわけで、各ステージをそれぞれmoduleでまとめるみたいな書き方してもそんなにわからり安くならないかもしれない
今みたいに書くコントロールが何クロック遅延するのかを明示的に書くというのも分かりやすくはある。
各ステージでmoduleを分けた方がタイミング制約は入れやすいかもしれないがそれはやったことがないのでわからない

9/02
2port ramにした
fiboが13を出力することを確認 
mifファイルのディレクトリ指定がちょっと謎
プログラムローダーのためにbitshiftが必要なので
bitshiftを実装する

9/03
bit shiftを実装した
コンパイラエクスプローラーを使ってプログラムローダーを書いてみた
これから動作確認をする（大変そう）
コンパイラエクスプローラー糞便利で驚いている
現状nopを手で入れないとハザードを回避できないのが非常に面倒なので
それの改善を最初にする

プログラムローダーの動作確認
プログラムローダーを用いて簡単なプログラムの実行
ハザードを自動で回避する部分の実装

read enableをbranchハザードの時に殺すのを忘れていた
このバグに直ぐ気づけたのはすごい！（自画自賛）

プログラムローダ動いた！！！
やった！！！！

aluとmemアクセスを同じクロックでやっているので、レジスタフォワーディングすればハザードが起きなくなる
レジスタフォワーディングを実装する

9/4
レジスタフォワーディングを実装して
プログラムローダが動いて、uartとfiboを確認した
今のプログラムは間にnopを入れているやつなのでそれを取り除いても大丈夫か確認したい
 -> 確認した 良い感じ
FPUの実装
タイミング制約の実装
FPUの段数を決めるためには、タイミング制約をちゃんとかけてどれくらいのクロックで動かすつもりなのか決めた方が良いかもという感じがするので

FPUのメモリアクセスをどうするか問題が発生した
パイプラインの長さをaluと変えると書き込むタイミングが競合する可能性がある
FPU専用メモリを用意するか？
と思ったがメモリアクセスはload-fpとstore-fpだけなのでそこだけ長さを変えれば万事ok

実は今のアーキテクチャではメモリにストアして直後にロードするとバグる気がしたがウソだった

riscv ツールチェインを弄ってみる
sdcファイルを書けばタイミング制約を入れられる気がするがよくわからない
タイミング制約を入れて、それによりどれくらいレジスタが増えるのか
色々な演算のチェックをする

9/5
riscv toolchainをビルドしてみたターゲットはrv32g
浮動小数点をどれくらい実装しようか
rv32iでビルドし直してみる
extentionのうち、mは普通に実装して良い気がする

なんかtoolchainうまく動かない
タイミング制約を入れてもがっつり遅延を減らしてくれるみたいなことをしてくれない
使うleの数がもっと増えて最適化するのかと思ったがそうでもないようである
rv32iを対象にしたコンパイラをとりあえずビルドしてみることにする
floatの命令を全て実装して、rv32if対象のコンパイルをするか？
divは11サイクルかかるけど

ストール対策が大変である
ソフトウェア側で対処するのは大変なので出来ればハードウェア側でストールしたい
nopを自動で入れるというのも無くはないけど…
ストールとブランチが絡んだ時にどうなるのかが悩みの種
どうやってストールを実装するとバグらないんだろう…
fpuの影響でストールするときにfpu以外のところを全部止めればいい気がする
fpu以外のところを全部止めるという実装だったらまあまあやりやすいんじゃないだろうか？
それより前にsoft floatを使ってレイトレを動かしてみるというのを先にやった方が良いかもしれない

ストールをうまくさせるには、レジスタを各ステージ毎にちゃんと分けて、clk enable信号を生やすのが良い気がする

fpuを実装して、fpu以外のクロックを止めるみたいな感じでハザードを回避するコアを書く
そしてminrtを何とかして動かすことを目標にする
minrtの前にpiとかを計算するやつを動かすことにする

9/6
rounding modeの事は気にしない
ipをそのまま使っていく
何Mhzを対象に作るか？
    2  3  4  5  6
add 56 73 85 102
mul    79 116
mad       38 51 64 

soft floatだとsoftfloat runtime libraryをリンクする感じになりそう
addが2サイクルで終わるやつにしてみる

fpuを簡単に書いた
todo

シミュレーターで2クロック遅れるというのがどうなっているのか確認する
実機にfpu ipが流し込めるか確認する
mulの追加
コントローラーの追加
フォアワーディングの実装
ストールはおいておいて動くかの確認
ストールの実装 <- fpuの実装とは独立にできるかも
load
store 
mv
cnvの実装

ストールは、do_branchと同じ感じにして、プログラムカウンタまわりだけ弄るというのが良い気がする

altera fpをmodelsimで動かすときは、 
'''
vsim -gui -l msim_transcript -L altera_mf_ver -L altera_mf -L sgate_ver -L sgate -L lpm_ver -L lpm work.fp_addsub_tb
'''
みたいなライブラリを追加する必要がある
シミュレート用の.voのポートの順番が間違っているので修正してコンパイルしたら動いた
なんかfpのmodelsimでのシミュレートが不安定だ
fp add とfp mulで遅延が何ステップなのかが違うように見える
fpadd は2clkck遅延と言っているけど、1clock後に出てくる
fpmul は3clkck遅延と言っていて、本当に3clock後に出てくる
これは実機通りなのか、それともどちらかがシミュレートがおかしいのか
とりあえずシミュレートに従って実装して、実機でずれたら修正するか

困ったらipを使わなくてもよい
とりあえずloadとストアが動くかを確認する
load store cvt mvを動かすのを先にやる
load store cvt mvのasmを書く
into_intregはwbするところのmuxを弄らなきゃいけなくてバグりそうなので後回し

9/8
loadとstoreのチェックから
asm.pyにちょっと追加してアセンブルして動かしてみた
reg_writeを書いてなかったので動かない
reg_writeを書く
fload fstoreが動くことを確認
cvt,mvを実装する wbのところのmuxはまとめた方が良い気がする
FPUの方がだいぶパイプラインの書き方の見た目が良い
nibuも書き直したさがある
mvとcvtのasmを書く
mvは動いた！
ipのlatencyが実機でどういう挙動を示すのかよくわからないので、
floating point のip確認用のプロジェクトを作って確認する
ftoiの確認が出来た
addのmodelsim用の遅延がぶっ壊れているみたいだ
portの順番も狂っているしダメだな

9/9
cvtが1clkかかるのでdata flowのちょっとした書き直し
fibo uart float float2の動作を確認
cvtの実装に入る
cvtを追加した
asmを書いてテストアセンブリを投げつけてみる
cvt.i.x -> mv.x.i -> show -> mv.i.x -> cvt.x.i -> send
みたいな関数が動くかを確かめるとよさそう
その後addとmul
cvtが動くことを確認！

9/10
addとmulの実装
'''
-O2 -march=rv32imf -mabi=ilp32f -mtune=generic
'''
でコンパイルするといいことが多い
-O2すると浮動小数点演算が少ない時にsoft floatライブラリを呼び出すという事があるようである
そうではなくて、cの浮動小数点定数がdoubleなのが問題であった
addが動いた！
シミュレーターがぶっ壊れてるのが困る
subも確認
mulも確認

ストールはプログラムカウンタだけ止めて書き込みを制限するみたいな感じが良いのではないだろうか
ストールに関するお絵描きをした

todo
コントロール信号線の整理 legal線をちゃんと走らせる
aluとmemアクセスの分離をしてパイプラインを5段にする
5段にしたことによるレジスタフォワーディングの修正
ストールの実装
FPU側のレジスタフォワーディング実装

fpuが絡まなければちゃんとテスト出来るので

コントロールラインを整理したのでデータフローを少し整理してパイプラインを5段にする

9/11

forwardingをするとき、二つ前にロード命令があったりするときに
それを取ってはいけないという制約が必要である気がする
しかしハザードdetectionユニットがそのような場合その命令を
ilegalと判定しているので無問題
パイプライン長くしたら一発で動いた
天才かもしれない

hazard detect unitを書いている
todo
各命令がrs1とrs2を使うかというコントロールを追加する
プログラムカウンタをmuxする部分を追加する

ハザードがちゃんと実装されたっぽい
nopなしのloaderがちゃんと動く
rtlシミュレートで一通りハザードしているところを見ても良いかも
色々テストコードを書いてちゃんと動くか確認した方が良いか？

todo
ハザードを起こすアセンブリを書く
上手くバブルしているかをrtlシミュレーションで確認する
use rs1あたりを再確認
FPUのフォアワーディング、バブルを書く

9/12 
rtlシミュレーションで確認
forward ctrlとforwardmuxを書いた
hazard ctrlを書く(nibuを見ながら)
hazardをfpuからnibuにつなげる
forwardを組み込む

is_hazard0,1,2を書く
一応できたように見える
todo 
cvtが遅いみたいなので、cvtとmvを分けてcvtを1クロック遅らせる
もう少し複雑なコードを書いてちゃんと動くか確認する

9/13
cmp命令を実装した
cmpのテストはok
gccはちゃんと4オペランド演算を出力するみたいである
gccの方がclangよりパイプラインとかを考慮した高速なコードを吐きそうに見える
todo
4オペランド演算を実装する
マンデルブロみたいのを実際に動かしたほうが良いかも？
もう少しコンパイルしやすくしたい
cross compileする設定のgccがなんか動いた
asm.pyを改良して、c言語を書くとコマンド一発で動くようにする

todo
最初にmainへのジャンプを追加する
liに対応する。
リンクする対象を変えてioが標準入出力に出来るようにする
hi%とli
1byteや2byte単位でのメモリアクセスがウザすぎる
アラインされてないメモリアクセスはgccの機能で排除できる
メモリユニットその時だけ2clockで動くようにして、前方にsh,sbがあるときはhazardにするというのが良さそう
とりあえずlh lhu lb lbuだけ実装してprint stringが自然に動くようにする
liはimmediateが大きすぎたらluiを入れなきゃいけないけど後回し

