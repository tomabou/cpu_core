FPGAが届いた

Quartusの使い方を何とか把握しようとした

PLLを使うことが出来た
model simを使った
シリアル通信モジュールを買った

シリアル通信を実装する

7/15
シリアル通信が動いた

次はメモリを使ってみるか？

メモリにシリアル通信でプログラムを配置して、実行するという形にしたい（ノイマン型）


8/20
院試が終わった
レジスタを書いてみた
riscvの仕様書を眺めてどれから実装しようか考える
先にどの命令を実装するか決めた方が良いかもしれない
とりあえずの目標を何にするか？
即値をレジスタに入れて、足し算
その次は条件分岐を入れてfibo
そのあとIOとメモリ

あとアセンブラを書いた方が良いかも
mifファイルを出力するやつ

8/21
とりあえず足し算を動かすことを目標にした
その後、メモリを使えるようにして、条件分岐を実装する。
大体パーツは書いたので、コントロールラインがクロックによって遅れることを実装すると足し算が動くはず
data memory はモック
コントロールはもっと複雑になったときにちゃんと書くのが大変そうである
case文のネストみたいな感じで書くのか
どれくらい論理合成するときに最適化してくれるかも不明
まあとりあえず動けばよい
明日中に実機で動くといいな
メモリを実機で使ったことがないのでちゃんと動くかは少し不安
あとPLLも

明日の予定
コントロールラインのパイプラインを書く
nibu.vのテストベンチを書く
実機で動かしてみる


8/22
微妙にmifファイルのmodelsimでの扱い方が分からない
Hizになってしまったので一回落としてもう一回起動したら動いた 謎
コントロールのパイプラインを書いた
add 0 でno opが実現できるか？
Noopを実装して、実機で動かす

mifファイルはmodelsimでは対応していないみたいである
現状quartusでコンパイルしておけば動くのだが、どのファイルが大事なのかはわからない
modelsimで再コンパイルすると死ぬ
mifファイルでなくhexファイルを使えばワンちゃんあるかも

あとはクロックを書けば多分動くのだが、mifファイルがガバいのはつらいので、それを修正するのが先かもしれない
50Mhzのクロックが入ってくるので、それこそ2Hzとかまで落として観測したい

8/23
メモリの謎のバグの原因が分かった
ramなのが悪い
多分ramはアドレスを効率的にするために内部配置を可変にしている
なので、mifファイルで初期化してもちゃんと初期化されないみたい
めっちゃ時間食われたけど解決してよかった

バグの原因はusbblasterからメモリの中身を見るやつだった
あれを入れるとめちゃくちゃになる

それとは別に、PCが突然5増えるというバグがある
noopを10挟むことでとりあえずその他の部分の確認はできたが、発生条件が分からない
rtlシミュレーションでは再現しない
leの表（ネットリスト？）を眺めてもなぜ5増えるのか全く分からない
単純に4を足しているだけなのに
これfpgaボードのせいである気がしていて、ledの下の方の出力を0にしておけば起こらない（必要十分条件からは程遠いと思うが）
どこかのLEDへのピンがonになっているときに、スイッチのチャタリング除去回路が機能しなくなっている説
それで高速にincrementだけされてうまくメモリが読みだされない みたいな
とりあえず10このLEDを光らせない方が良い気がする

あまり納得できないが、とりあえずRTLシミュレーションとFPGAの挙動が一致したので、次の機能を実装していく
ramと、ジャンプ系
memory mapped ioを使うので、ramを実装した後に実装したい

順序としては、
2オペランド演算
ジャンプ
1から6までの和の計算
ram
フィボナッチ
io
対話式の何か

対話式の何かはコンパイラが無いとキツそうである
コンパイラをどうするか
とりあえずclangを使ってみるか？
それともフルスクラッチで書くか
その前に多分アセンブラ(to mif file)が必要だけど


8/24

2オペランド演算は多分動いてる
mifファイルをmodelsim側から読む方法が分からないので、
mifを弄るたびに起動し直すのがめんどくさい
ので、先にテストファイルを作る必要がある
これは多分アセンブラが必要
アセンブラは軽井沢で作るかな

このdataflowだと、PCを読む方法がないので、AUIPC(add upper immediate to pc)が実装できない
あとJAL JALRも
JALはPCをwrite registerに流し込めれば大丈夫
JALRはそれに加えてregisterの値をPCに足す部分が必要
aluを利用するのか、それとも別のmoduleを用意するのか
conditional branchは実装できる

JALをまず実装して、その後conditional branch
JALRってジャンプ先計算する前にregisterから読みださなきゃいけないからパフォーマンスどうしても落ちそう
でもかなり遠いところに飛ぶときしか使わないから、まあ大丈夫なのかな

JALを書いたつもり
テストケースを書くのがそろそろ面倒なので、アセンブラとシミュレータがそろそろ欲しくなってきた
軽井沢で書けたら良いなー

8/25
addとaddiのアセンブラを書いた
mifを出力して実機に書き込んで動くところまで確認
次は
ジャンプ命令をdecodeできるようにしてunconditional jumpの挙動を確認する

パイプライン回りをどれくらい真面目に実装するか
register forwardingとか実装するか？？
別にパイプラインしなくても定数倍遅くなってそれで終わり